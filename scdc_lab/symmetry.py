from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Optional, Sequence, Tuple
from collections import deque

import numpy as np
from sympy.combinatorics.permutations import Permutation
from sympy.combinatorics.perm_groups import PermutationGroup


# ----------------------------
# Discrete (star) symmetry
# ----------------------------

def star_symmetry_group(in_sources: Sequence[int]) -> PermutationGroup:
    """Permutation group generated by adjacent swaps within equal-source bundles.

    This matches the star automorphisms AutIn(v): permutations of input edges preserving sources.
    """
    m = len(in_sources)
    source_to_indices: Dict[int, List[int]] = {}
    for i, s in enumerate(in_sources):
        source_to_indices.setdefault(int(s), []).append(int(i))

    gens: List[Permutation] = []
    for indices in source_to_indices.values():
        if len(indices) <= 1:
            continue
        idx = sorted(indices)
        for a, b in zip(idx[:-1], idx[1:]):
            perm = list(range(m))
            perm[a], perm[b] = perm[b], perm[a]
            gens.append(Permutation(perm))

    if not gens:
        return PermutationGroup([Permutation(list(range(m)))])
    return PermutationGroup(gens)


# ----------------------------
# Braid representations (exploratory)
# ----------------------------

def reduced_burau_B3_mod_p(t: int, p: int) -> Tuple[np.ndarray, np.ndarray]:
    """Reduced Burau representation of B3 over F_p (dim 2)."""
    p = int(p)
    t = int(t % p)
    if t == 0:
        raise ValueError("t must be nonzero mod p.")
    s1 = np.array([[-t % p, 1 % p], [0, 1]], dtype=int) % p
    s2 = np.array([[1, 0], [t % p, (-t) % p]], dtype=int) % p
    return s1, s2


def burau_like_B4_mod_p(t: int, p: int) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """A 3x3 'Burau-like' representation for B4 mod p.

    WARNING:
    This is an exploratory construction aligned with the matrices used in the lab scripts.
    It should be treated as a computational probe rather than a theorem.

    Generators: σ1, σ2, σ3.
    """
    p = int(p)
    t = int(t % p)
    if t == 0:
        raise ValueError("t must be nonzero mod p.")

    s1 = np.array([[-t, 1, 0],
                   [0, 1, 0],
                   [0, 0, 1]], dtype=int) % p
    s2 = np.array([[1, 0, 0],
                   [t, -t, 1],
                   [0, 0, 1]], dtype=int) % p
    s3 = np.array([[1, 0, 0],
                   [0, 1, 0],
                   [0, t, -t]], dtype=int) % p
    return s1, s2, s3


# ----------------------------
# Finite matrix groups by enumeration
# ----------------------------

@dataclass
class MatrixGroupResult:
    order: Optional[int]  # None means truncated
    truncated: bool
    elements: List[np.ndarray]
    p: int


def matrix_group_generated(
    generators: Sequence[np.ndarray],
    p: int,
    max_size: int = 20000,
) -> MatrixGroupResult:
    """Enumerate the finite subgroup generated by matrices in GL(d, F_p) (by BFS)."""
    if len(generators) == 0:
        raise ValueError("Need at least one generator.")
    p = int(p)
    gens = [np.array(g, dtype=int) % p for g in generators]
    dim = int(gens[0].shape[0])

    def key_mod(M: np.ndarray) -> Tuple[int, ...]:
        return tuple(int(x) for x in (M % p).reshape(-1))

    I = np.eye(dim, dtype=int) % p
    seen = {key_mod(I)}
    elems: List[np.ndarray] = [I]
    q = deque([I])

    while q and len(elems) < int(max_size):
        M = q.popleft()
        for g in gens:
            N = (M @ g) % p
            k = key_mod(N)
            if k not in seen:
                seen.add(k)
                elems.append(N)
                q.append(N)
                if len(elems) >= int(max_size):
                    break

    truncated = bool(q) and len(elems) >= int(max_size)
    order = None if truncated else int(len(elems))
    return MatrixGroupResult(order=order, truncated=truncated, elements=elems, p=p)


def is_abelian(elements: Sequence[np.ndarray], p: int, max_checks: int = 500) -> bool:
    """Heuristic abelian check via commutator sampling."""
    p = int(p)
    if len(elements) <= 2:
        return True
    m = min(int(max_checks), len(elements))
    for i in range(m):
        A = elements[i] % p
        for j in range(m):
            B = elements[j] % p
            if not np.array_equal((A @ B) % p, (B @ A) % p):
                return False
    return True
